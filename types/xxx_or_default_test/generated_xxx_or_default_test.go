package types_xxx_or_default_test

// This code has been automatically generated by:
// _dev_scripts/test_codegen/generate_xxx_or_default_test.py
// Do NOT edit or append.

import (
	"encoding/json"
	"fmt"
	aastesting "github.com/aas-core-works/aas-core3.0-golang/aastesting"
	aasstringification "github.com/aas-core-works/aas-core3.0-golang/stringification"
	aastypes "github.com/aas-core-works/aas-core3.0-golang/types"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"testing"
)

// Represent explicitly a literal of an enumeration.
type enumerationLiteral struct {
	enumerationName string
	literalName     string
}

func (el *enumerationLiteral) String() string {
	return fmt.Sprintf("%s.%s", el.enumerationName, el.literalName)
}

// Marshal the value as JSON, or panic otherwise.
func mustJSONMarshal(value interface{}) string {
	bb, err := json.Marshal(value)
	if err != nil {
		panic(
			fmt.Sprintf(
				"Failed to marshal the value %v to JSON: %s",
				value, err.Error(),
			),
		)
	}

	return string(bb)
}

func stringify(value interface{}) (got string) {
	if value == nil {
		got = mustJSONMarshal(value)
	} else {
		// See: https://stackoverflow.com/questions/38748098/golang-type-switch-how-to-match-a-generic-slice-array-map-chan
		reflected := reflect.ValueOf(value)

		if reflected.Kind() == reflect.Slice {
			parts := make([]string, reflected.Len())

			for i := 0; i < reflected.Len(); i++ {
				item := reflected.Index(i)
				parts[i] = stringify(item)
			}

			got = fmt.Sprintf("[%s]", strings.Join(parts, ", "))
		} else {
			switch casted := value.(type) {
			case bool:
				got = mustJSONMarshal(casted)
			case int:
				got = mustJSONMarshal(casted)
			case string:
				got = mustJSONMarshal(casted)
			case []byte:
				got = fmt.Sprintf("%d byte(s)", len(casted))
			case *enumerationLiteral:
				got = casted.String()
			case aastypes.IClass:
				got = aastesting.TraceMark(casted)
			default:
				panic(
					fmt.Sprintf(
						"We do not know hot to represent the value of type %T: %v",
						value, value,
					),
				)
			}
		}
	}

	return
}

// Represent `value` such that we can immediately check whether it is the default value
// or the set one.
//
// We compare it against the recorded golden file, if not [aastesting.RecordMode].
// If there are differences, a `message` is set.
//
// Otherwise, when [aastesting.RecordMode] is set, we re-record the golden file.
func compareOrRerecordValue(
	value interface{},
	expectedPath string,
) (message *string) {
	got := stringify(value)

	// NOTE (mristin, 2023-06-07):
	// Add a new line for POSIX systems.
	got += "\n"

	if aastesting.RecordMode {
		parent := filepath.Dir(expectedPath)
		err := os.MkdirAll(parent, os.ModePerm)
		if err != nil {
			panic(
				fmt.Sprintf(
					"Failed to create the directory %s: %s", parent, err.Error(),
				),
			)
		}

		err = os.WriteFile(expectedPath, []byte(got), 0644)
		if err != nil {
			panic(
				fmt.Sprintf(
					"Failed to write to the file %s: %s", expectedPath, err.Error(),
				),
			)
		}
	} else {
		bb, err := os.ReadFile(expectedPath)
		if err != nil {
			panic(
				fmt.Sprintf(
					"Failed to read from file %s: %s", expectedPath, err.Error(),
				),
			)
		}

		expected := string(bb)

		// NOTE (mristin, 2023-06-07):
		// Git automatically strips and adds `\r`, so we have to remove it here
		// to obtain a canonical text.
		expected = strings.Replace(expected, "\r", "", -1)

		if expected != got {
			text := fmt.Sprintf(
				"What we got differs from the expected in %s. "+
					"We got:\n%s\nWe expected:\n%s",
				expectedPath, got, expected,
			)
			message = &text
		}
	}

	return
}

func TestExtensionValueTypeOrDefaultDefault(t *testing.T) {
	instance := aastesting.MustLoadMinimalExtension()

	value := &enumerationLiteral{
		enumerationName: "QualifierKind",
		literalName: aasstringification.MustDataTypeDefXSDToString(
			instance.ValueTypeOrDefault(),
		),
	}

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"Extension",
		"ValueTypeOrDefault.default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestExtensionValueTypeOrDefaultNonDefault(t *testing.T) {
	instance := aastesting.MustLoadMaximalExtension()

	value := &enumerationLiteral{
		enumerationName: "QualifierKind",
		literalName: aasstringification.MustDataTypeDefXSDToString(
			instance.ValueTypeOrDefault(),
		),
	}

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"Extension",
		"ValueTypeOrDefault.non-default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestQualifierKindOrDefaultDefault(t *testing.T) {
	instance := aastesting.MustLoadMinimalQualifier()

	value := &enumerationLiteral{
		enumerationName: "QualifierKind",
		literalName: aasstringification.MustQualifierKindToString(
			instance.KindOrDefault(),
		),
	}

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"Qualifier",
		"KindOrDefault.default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestQualifierKindOrDefaultNonDefault(t *testing.T) {
	instance := aastesting.MustLoadMaximalQualifier()

	value := &enumerationLiteral{
		enumerationName: "QualifierKind",
		literalName: aasstringification.MustQualifierKindToString(
			instance.KindOrDefault(),
		),
	}

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"Qualifier",
		"KindOrDefault.non-default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestSubmodelKindOrDefaultDefault(t *testing.T) {
	instance := aastesting.MustLoadMinimalSubmodel()

	value := &enumerationLiteral{
		enumerationName: "QualifierKind",
		literalName: aasstringification.MustModellingKindToString(
			instance.KindOrDefault(),
		),
	}

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"Submodel",
		"KindOrDefault.default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestSubmodelKindOrDefaultNonDefault(t *testing.T) {
	instance := aastesting.MustLoadMaximalSubmodel()

	value := &enumerationLiteral{
		enumerationName: "QualifierKind",
		literalName: aasstringification.MustModellingKindToString(
			instance.KindOrDefault(),
		),
	}

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"Submodel",
		"KindOrDefault.non-default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestSubmodelElementListOrderRelevantOrDefaultDefault(t *testing.T) {
	instance := aastesting.MustLoadMinimalSubmodelElementList()

	value := instance.OrderRelevantOrDefault()

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"SubmodelElementList",
		"OrderRelevantOrDefault.default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestSubmodelElementListOrderRelevantOrDefaultNonDefault(t *testing.T) {
	instance := aastesting.MustLoadMaximalSubmodelElementList()

	value := instance.OrderRelevantOrDefault()

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"SubmodelElementList",
		"OrderRelevantOrDefault.non-default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestPropertyCategoryOrDefaultDefault(t *testing.T) {
	instance := aastesting.MustLoadMinimalProperty()

	value := instance.CategoryOrDefault()

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"Property",
		"CategoryOrDefault.default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestPropertyCategoryOrDefaultNonDefault(t *testing.T) {
	instance := aastesting.MustLoadMaximalProperty()

	value := instance.CategoryOrDefault()

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"Property",
		"CategoryOrDefault.non-default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestMultiLanguagePropertyCategoryOrDefaultDefault(t *testing.T) {
	instance := aastesting.MustLoadMinimalMultiLanguageProperty()

	value := instance.CategoryOrDefault()

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"MultiLanguageProperty",
		"CategoryOrDefault.default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestMultiLanguagePropertyCategoryOrDefaultNonDefault(t *testing.T) {
	instance := aastesting.MustLoadMaximalMultiLanguageProperty()

	value := instance.CategoryOrDefault()

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"MultiLanguageProperty",
		"CategoryOrDefault.non-default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestRangeCategoryOrDefaultDefault(t *testing.T) {
	instance := aastesting.MustLoadMinimalRange()

	value := instance.CategoryOrDefault()

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"Range",
		"CategoryOrDefault.default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestRangeCategoryOrDefaultNonDefault(t *testing.T) {
	instance := aastesting.MustLoadMaximalRange()

	value := instance.CategoryOrDefault()

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"Range",
		"CategoryOrDefault.non-default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestReferenceElementCategoryOrDefaultDefault(t *testing.T) {
	instance := aastesting.MustLoadMinimalReferenceElement()

	value := instance.CategoryOrDefault()

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"ReferenceElement",
		"CategoryOrDefault.default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestReferenceElementCategoryOrDefaultNonDefault(t *testing.T) {
	instance := aastesting.MustLoadMaximalReferenceElement()

	value := instance.CategoryOrDefault()

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"ReferenceElement",
		"CategoryOrDefault.non-default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestBlobCategoryOrDefaultDefault(t *testing.T) {
	instance := aastesting.MustLoadMinimalBlob()

	value := instance.CategoryOrDefault()

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"Blob",
		"CategoryOrDefault.default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestBlobCategoryOrDefaultNonDefault(t *testing.T) {
	instance := aastesting.MustLoadMaximalBlob()

	value := instance.CategoryOrDefault()

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"Blob",
		"CategoryOrDefault.non-default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestFileCategoryOrDefaultDefault(t *testing.T) {
	instance := aastesting.MustLoadMinimalFile()

	value := instance.CategoryOrDefault()

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"File",
		"CategoryOrDefault.default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

func TestFileCategoryOrDefaultNonDefault(t *testing.T) {
	instance := aastesting.MustLoadMaximalFile()

	value := instance.CategoryOrDefault()

	expectedPth := filepath.Join(
		aastesting.TestDataDir,
		"XxxOrDefault",
		"File",
		"CategoryOrDefault.non-default.txt",
	)

	message := compareOrRerecordValue(
		value,
		expectedPth,
	)

	if message != nil {
		t.Fatal(*message)
	}
}

// This code has been automatically generated by:
// _dev_scripts/test_codegen/generate_xxx_or_default_test.py
// Do NOT edit or append.
