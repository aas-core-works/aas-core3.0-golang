package jsonization_test

// This code has been automatically generated by:
// _dev_scripts/test_codegen/generate_jsonization_of_concrete_classes_outside_container_test.py
// Do NOT edit or append.

import (
	aastesting "github.com/aas-core-works/aas-core3.0-golang/aastesting"
	aasjsonization "github.com/aas-core-works/aas-core3.0-golang/jsonization"
	"testing"
)

func TestExtensionRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalExtension()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal Extension: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal Extension>"

	deserialized, deseriaErr := aasjsonization.ExtensionFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestAdministrativeInformationRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalAdministrativeInformation()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal AdministrativeInformation: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal AdministrativeInformation>"

	deserialized, deseriaErr := aasjsonization.AdministrativeInformationFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestQualifierRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalQualifier()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal Qualifier: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal Qualifier>"

	deserialized, deseriaErr := aasjsonization.QualifierFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestAssetAdministrationShellRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalAssetAdministrationShell()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal AssetAdministrationShell: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal AssetAdministrationShell>"

	deserialized, deseriaErr := aasjsonization.AssetAdministrationShellFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestAssetInformationRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalAssetInformation()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal AssetInformation: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal AssetInformation>"

	deserialized, deseriaErr := aasjsonization.AssetInformationFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestResourceRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalResource()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal Resource: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal Resource>"

	deserialized, deseriaErr := aasjsonization.ResourceFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestSpecificAssetIDRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalSpecificAssetID()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal SpecificAssetId: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal SpecificAssetId>"

	deserialized, deseriaErr := aasjsonization.SpecificAssetIDFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestSubmodelRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalSubmodel()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal Submodel: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal Submodel>"

	deserialized, deseriaErr := aasjsonization.SubmodelFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestRelationshipElementRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalRelationshipElement()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal RelationshipElement: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal RelationshipElement>"

	deserialized, deseriaErr := aasjsonization.RelationshipElementFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestSubmodelElementListRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalSubmodelElementList()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal SubmodelElementList: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal SubmodelElementList>"

	deserialized, deseriaErr := aasjsonization.SubmodelElementListFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestSubmodelElementCollectionRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalSubmodelElementCollection()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal SubmodelElementCollection: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal SubmodelElementCollection>"

	deserialized, deseriaErr := aasjsonization.SubmodelElementCollectionFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestPropertyRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalProperty()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal Property: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal Property>"

	deserialized, deseriaErr := aasjsonization.PropertyFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestMultiLanguagePropertyRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalMultiLanguageProperty()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal MultiLanguageProperty: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal MultiLanguageProperty>"

	deserialized, deseriaErr := aasjsonization.MultiLanguagePropertyFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestRangeRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalRange()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal Range: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal Range>"

	deserialized, deseriaErr := aasjsonization.RangeFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestReferenceElementRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalReferenceElement()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal ReferenceElement: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal ReferenceElement>"

	deserialized, deseriaErr := aasjsonization.ReferenceElementFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestBlobRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalBlob()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal Blob: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal Blob>"

	deserialized, deseriaErr := aasjsonization.BlobFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestFileRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalFile()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal File: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal File>"

	deserialized, deseriaErr := aasjsonization.FileFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestAnnotatedRelationshipElementRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalAnnotatedRelationshipElement()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal AnnotatedRelationshipElement: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal AnnotatedRelationshipElement>"

	deserialized, deseriaErr := aasjsonization.AnnotatedRelationshipElementFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestEntityRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalEntity()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal Entity: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal Entity>"

	deserialized, deseriaErr := aasjsonization.EntityFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestBasicEventElementRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalBasicEventElement()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal BasicEventElement: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal BasicEventElement>"

	deserialized, deseriaErr := aasjsonization.BasicEventElementFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestOperationRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalOperation()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal Operation: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal Operation>"

	deserialized, deseriaErr := aasjsonization.OperationFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestOperationVariableRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalOperationVariable()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal OperationVariable: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal OperationVariable>"

	deserialized, deseriaErr := aasjsonization.OperationVariableFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestCapabilityRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalCapability()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal Capability: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal Capability>"

	deserialized, deseriaErr := aasjsonization.CapabilityFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestConceptDescriptionRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalConceptDescription()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal ConceptDescription: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal ConceptDescription>"

	deserialized, deseriaErr := aasjsonization.ConceptDescriptionFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestReferenceRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalReference()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal Reference: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal Reference>"

	deserialized, deseriaErr := aasjsonization.ReferenceFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestKeyRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalKey()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal Key: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal Key>"

	deserialized, deseriaErr := aasjsonization.KeyFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestLangStringNameTypeRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalLangStringNameType()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal LangStringNameType: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal LangStringNameType>"

	deserialized, deseriaErr := aasjsonization.LangStringNameTypeFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestLangStringTextTypeRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalLangStringTextType()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal LangStringTextType: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal LangStringTextType>"

	deserialized, deseriaErr := aasjsonization.LangStringTextTypeFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestEmbeddedDataSpecificationRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalEmbeddedDataSpecification()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal EmbeddedDataSpecification: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal EmbeddedDataSpecification>"

	deserialized, deseriaErr := aasjsonization.EmbeddedDataSpecificationFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestLevelTypeRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalLevelType()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal LevelType: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal LevelType>"

	deserialized, deseriaErr := aasjsonization.LevelTypeFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestValueReferencePairRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalValueReferencePair()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal ValueReferencePair: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal ValueReferencePair>"

	deserialized, deseriaErr := aasjsonization.ValueReferencePairFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestValueListRoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalValueList()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal ValueList: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal ValueList>"

	deserialized, deseriaErr := aasjsonization.ValueListFromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestLangStringPreferredNameTypeIEC61360RoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalLangStringPreferredNameTypeIEC61360()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal LangStringPreferredNameTypeIec61360: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal LangStringPreferredNameTypeIec61360>"

	deserialized, deseriaErr := aasjsonization.LangStringPreferredNameTypeIEC61360FromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestLangStringShortNameTypeIEC61360RoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalLangStringShortNameTypeIEC61360()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal LangStringShortNameTypeIec61360: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal LangStringShortNameTypeIec61360>"

	deserialized, deseriaErr := aasjsonization.LangStringShortNameTypeIEC61360FromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestLangStringDefinitionTypeIEC61360RoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalLangStringDefinitionTypeIEC61360()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal LangStringDefinitionTypeIec61360: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal LangStringDefinitionTypeIec61360>"

	deserialized, deseriaErr := aasjsonization.LangStringDefinitionTypeIEC61360FromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}

func TestDataSpecificationIEC61360RoundTripOKOutsideContainer(t *testing.T) {
	instance := aastesting.MustLoadMaximalDataSpecificationIEC61360()

	jsonable, err := aasjsonization.ToJsonable(instance)
	if err != nil {
		t.Fatalf(
			"Failed to serialize the maximal DataSpecificationIec61360: %s",
			err.Error(),
		)
		return
	}

	source := "<maximal DataSpecificationIec61360>"

	deserialized, deseriaErr := aasjsonization.DataSpecificationIEC61360FromJsonable(
		jsonable,
	)
	ok := assertNoDeserializationError(t, deseriaErr, source)
	if !ok {
		return
	}

	anotherJsonable, seriaErr := aasjsonization.ToJsonable(deserialized)
	ok = assertNoSerializationError(t, seriaErr, source)
	if !ok {
		return
	}

	ok = assertSerializationEqualsDeserialization(
		t,
		jsonable,
		anotherJsonable,
		source,
	)
	if !ok {
		return
	}
}
