package enhancing_test

// This code has been automatically generated by:
// _dev_scripts/test_codegen/generate_enhancing_test.py
// Do NOT edit or append.

import (
	aastesting "github.com/aas-core-works/aas-core3.0-golang/aastesting"
	aasenhancing "github.com/aas-core-works/aas-core3.0-golang/enhancing"
	aastypes "github.com/aas-core-works/aas-core3.0-golang/types"
	"testing"
)

type Enhancement struct {
	ID int
}

func collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
	t *testing.T,
	wrapped aastypes.IClass,
	nextID int,
) {
	var ids []int

	instanceEnh := aasenhancing.MustUnwrap[*Enhancement](wrapped)
	ids = append(ids, instanceEnh.ID)

	wrapped.Descend(
		func(that aastypes.IClass) (abort bool) {
			enh := aasenhancing.MustUnwrap[*Enhancement](that)
			ids = append(ids, enh.ID)
			return
		},
	)

	if len(ids) != nextID {
		t.Fatalf("Expected to collect %d IDs, but got: %d", len(ids), nextID)
		return
	}

	for i, id := range ids {
		if id != i {
			t.Fatalf(
				"Unexpected ID at index %d (starting from 0); expected %d, got %d",
				i, i, id,
			)
		}
	}
}

func TestExtensionWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalExtension()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestExtensionNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalExtension()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestAdministrativeInformationWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalAdministrativeInformation()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestAdministrativeInformationNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalAdministrativeInformation()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestQualifierWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalQualifier()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestQualifierNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalQualifier()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestAssetAdministrationShellWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalAssetAdministrationShell()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestAssetAdministrationShellNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalAssetAdministrationShell()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestAssetInformationWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalAssetInformation()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestAssetInformationNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalAssetInformation()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestResourceWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalResource()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestResourceNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalResource()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestSpecificAssetIDWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalSpecificAssetID()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestSpecificAssetIDNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalSpecificAssetID()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestSubmodelWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalSubmodel()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestSubmodelNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalSubmodel()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestRelationshipElementWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalRelationshipElement()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestRelationshipElementNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalRelationshipElement()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestSubmodelElementListWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalSubmodelElementList()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestSubmodelElementListNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalSubmodelElementList()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestSubmodelElementCollectionWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalSubmodelElementCollection()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestSubmodelElementCollectionNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalSubmodelElementCollection()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestPropertyWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalProperty()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestPropertyNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalProperty()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestMultiLanguagePropertyWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalMultiLanguageProperty()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestMultiLanguagePropertyNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalMultiLanguageProperty()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestRangeWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalRange()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestRangeNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalRange()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestReferenceElementWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalReferenceElement()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestReferenceElementNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalReferenceElement()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestBlobWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalBlob()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestBlobNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalBlob()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestFileWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalFile()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestFileNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalFile()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestAnnotatedRelationshipElementWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalAnnotatedRelationshipElement()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestAnnotatedRelationshipElementNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalAnnotatedRelationshipElement()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestEntityWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalEntity()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestEntityNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalEntity()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestEventPayloadWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalEventPayload()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestEventPayloadNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalEventPayload()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestBasicEventElementWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalBasicEventElement()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestBasicEventElementNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalBasicEventElement()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestOperationWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalOperation()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestOperationNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalOperation()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestOperationVariableWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalOperationVariable()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestOperationVariableNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalOperationVariable()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestCapabilityWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalCapability()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestCapabilityNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalCapability()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestConceptDescriptionWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalConceptDescription()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestConceptDescriptionNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalConceptDescription()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestReferenceWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalReference()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestReferenceNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalReference()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestKeyWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalKey()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestKeyNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalKey()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestLangStringNameTypeWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalLangStringNameType()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestLangStringNameTypeNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalLangStringNameType()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestLangStringTextTypeWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalLangStringTextType()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestLangStringTextTypeNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalLangStringTextType()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestEnvironmentWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalEnvironment()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestEnvironmentNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalEnvironment()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestEmbeddedDataSpecificationWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalEmbeddedDataSpecification()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestEmbeddedDataSpecificationNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalEmbeddedDataSpecification()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestLevelTypeWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalLevelType()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestLevelTypeNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalLevelType()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestValueReferencePairWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalValueReferencePair()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestValueReferencePairNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalValueReferencePair()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestValueListWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalValueList()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestValueListNothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalValueList()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestLangStringPreferredNameTypeIEC61360Wrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalLangStringPreferredNameTypeIEC61360()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestLangStringPreferredNameTypeIEC61360NothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalLangStringPreferredNameTypeIEC61360()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestLangStringShortNameTypeIEC61360Wrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalLangStringShortNameTypeIEC61360()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestLangStringShortNameTypeIEC61360NothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalLangStringShortNameTypeIEC61360()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestLangStringDefinitionTypeIEC61360Wrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalLangStringDefinitionTypeIEC61360()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestLangStringDefinitionTypeIEC61360NothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalLangStringDefinitionTypeIEC61360()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}

func TestDataSpecificationIEC61360Wrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalDataSpecificationIEC61360()

	nextID := 0
	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			enh = &Enhancement{}
			enh.ID = nextID
			should = true

			nextID++
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	collectIDsAndAssertTheyAreConsecutiveAndTheirCountEqualsNextID(
		t, wrapped, nextID,
	)
}

func TestDataSpecificationIEC61360NothingWrapped(t *testing.T) {
	instance := aastesting.MustLoadMaximalDataSpecificationIEC61360()

	wrapped := aasenhancing.Wrap[*Enhancement](
		instance,
		func(that aastypes.IClass) (enh *Enhancement, should bool) {
			should = false
			return
		},
	)

	if !aastesting.DeepEqual(instance, wrapped) {
		t.Fatalf(
			"Deep equality failed between the instance and the wrapped: %v %v",
			instance, wrapped,
		)
	}

	// Wrapped should be equal to instance by reference as our enhancement factory
	// did not wrap anything.
	if wrapped != instance {
		t.Fatalf("Unexpected inequality between %v and %v", wrapped, instance)
	}

	wrapped.Descend(func(that aastypes.IClass) (abort bool) {
		_, ok := aasenhancing.Unwrap[*Enhancement](that)
		if ok {
			t.Fatalf("Unexpected wrapped descendant: %v", that)
		}
		return
	})
}
